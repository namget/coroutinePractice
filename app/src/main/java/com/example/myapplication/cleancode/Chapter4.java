package com.example.myapplication.cleancode;

public class Chapter4 {


//    private final String HTTP_DATE_REGEXP =
//            "[SMTWF][a-z]{2}\\,\\s[0-9]{2}\\s[J FMASOND][a-z]{2}\\sM+[0-9]{4}\\s[0-9]{2}\\:[0-9]{2}\\:[0-9]{2}\\sGMT";
//
//    private Response response;
//
//    private FitNesseContext context;
//
//    private FileResponder responder;
//
//    private Locale saveLocale;

//    assertTrue(a.compareTo(a) == 0) ； // a == a


//    String listltemContent = match.group(3).trim();
//    // 여기서 trim은 정말 중요하다. trim 함수는 문자열에서 시작 공백을 제거한다.
//    // 문자열에 시작 공백이 있으면 다른 문자열로 인식되기 때문이다.
//    new ListltemWidget(this,listltemContent, this.level + 1);
//    return buildList(text.substring(match.end()));

//    //this .closed 가 true 일 때 반환되는 유틸리티 메서드다.
//    //타임아웃에 도달하면 예외를 던진다.
//    public synchronized void waitForClose(finaI long timeoutMillis)
//            throws Exception {
//        if (!closed) {
//            wait(timeoutMillis);
//            if (!closed)
//                throw new Exception("MockResponseSender could not be closed");
//        }
//    }

//    private void startSending() {
//        try {
//            doSending();
//        } catch (SocketException e) {
//            // 정상. 누군가 요청을 멈췄다.
//        } catch (Exception e) {
//            try {
//                response.add(ErrorResponder.makeExceptionString(e));
//                response.closeAll();
//            } catch (Exception el) {
//                // 이게 뭐야!
//            }
//        }
//    }
//
//    /** The name. */
//    private String name;
//    /** The version. */
//    private String version;
//    /** The licenceName. */
//    private String licenceName;
//    /** The version. */
//    private String info;
//    /**
//     * 모든 픽셀을 담을 만큼 충분한 배열로 시작한다(여기에 필터 바이트를 더한다) .
//     * 그리고 헤더 정보를 위해 200바이트를 더한다.
//     */
//            this.pngBytes =new byte[((this.width +1)*this.height *3)+200];


}

